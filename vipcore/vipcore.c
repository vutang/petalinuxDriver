/*  vipcore.c - The simplest kernel module.
 */
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>

#include "vipcore.h"

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Xilinx Inc.");
MODULE_DESCRIPTION
    ("vipcore - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "vipcore"

/* Simple example of how to receive command line parameters to your module.
   Delete if you don't need them */
// unsigned myint = 0xdeadbeef;
// char *mystr = "default";

// module_param(myint, int, S_IRUGO);
// module_param(mystr, charp, S_IRUGO);

struct vipcore_local {
	int irq;
	unsigned long mem_start;
	unsigned long mem_end;
	void __iomem *base_addr;
};

static inline void vip_write(struct vip_state *st, unsigned reg, unsigned val) {
	iowrite32(val, st->regs + reg);
}

int vip_write_reg(u32 reg, u32 value) {
	int ret = 0;
	vip_write(st, reg, value);
	// msleep(200);
	return ret;
}
EXPORT_SYMBOL_GPL(vip_write_reg);

static irqreturn_t vipcore_irq(int irq, void *lp)
{
	printk("vipcore interrupt\n");
	return IRQ_HANDLED;
}

static struct of_device_id vipcore_of_match[] = {
	{ .compatible = "xlnx,led-controller-v1-0-1.0", },
	{ /* end of list */ },
};
MODULE_DEVICE_TABLE(of, vipcore_of_match);

static int vipcore_probe(struct platform_device *pdev) {	
	struct of_device_id *id;
	int rc;

	struct resource *mem;
	printk("[VUTT6] Probing device %s...\n", pdev->dev.of_node->name);
	id = of_match_device(vipcore_of_match, &pdev->dev);
	if(!id){
		return -ENODEV;
	}

	st = kzalloc(sizeof(struct vip_state), GFP_KERNEL);

	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	/*Mapping the physical mem to virtual mem???*/
	st->regs = devm_ioremap_resource(&pdev->dev, mem);

	if (IS_ERR(st->regs)){
		return PTR_ERR(st->regs);
	}
	printk("[VUTT6] Probing device %s successfully...\n", pdev->dev.of_node->name);

	vip_write(st, 0, 1);
	return rc;
}

static int vipcore_remove(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct vipcore_local *lp = dev_get_drvdata(dev);
	free_irq(lp->irq, lp);
	release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return 0;
}

static struct platform_driver vipcore_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= vipcore_of_match,
	},
	.probe		= vipcore_probe,
	.remove		= vipcore_remove,
};

static int __init vipcore_init(void)
{
	printk("<1>Hello module world.\n");
	// printk("<1>Module parameters were (0x%08x) and \"%s\"\n", myint,
	       // mystr);

	return platform_driver_register(&vipcore_driver);
}


static void __exit vipcore_exit(void)
{
	platform_driver_unregister(&vipcore_driver);
	printk(KERN_ALERT "Goodbye module world.\n");
}

module_init(vipcore_init);
module_exit(vipcore_exit);

